import {
    SaveContext,
    SaveBundle,
    SaveResult,
    Entity,
    AutoGeneratedKeyType,
    DataProperty,
    DataType,
    HttpResponse,
    EntityKey
} from 'breeze-client';

import { CustomDataServiceUtils } from './sp-dataservice-utils';

export class CustomSaveContext {

    private headers: Object;

    constructor(private saveContext: SaveContext,
        private saveBundle: SaveBundle,
        private utils: CustomDataServiceUtils) {
    }

    private addKeyMapping(response: HttpResponse,
        index: number, unwrappedResponse: any): any {

        const tempKey = response.saveContext.tempKeys[index] as EntityKey;
        if (tempKey) {
            // entity had a temporary key; add a temp-to-perm key mapping
            const entityType = tempKey.entityType;
            const tempValue = tempKey.values[0];
            const realKey = entityType.getEntityKeyFromRawEntity(entityType, unwrappedResponse);
            const keyMapping = {
                entityTypeName: entityType.name,
                tempValue: tempValue,
                realValue: realKey.values[0]
            };
            response.saveContext.saveResult.keyMappings.push(keyMapping);
        }

    }

    private makeSaveResult(response: HttpResponse, index: number): SaveResult {
        let data = this.utils.unwrapResponseData(response);
        
        if (data && typeof data === 'object') {
            // Have "saved entity" data; add its type (for JsonResultsAdapter) & KeyMapping
            data.$entityType = response.saveContext
                .originalEntities[index].entityType;
            this.addKeyMapping(response, index, data);
        } else {
            // No "saved entity" data; return the original entity
            data = this.saveContext.originalEntities[index];
        }
    }

    private prepareSaveBundles(): Promise<SaveResult>[] {
        this.saveContext.tempKeys = [];
        this.saveContext.originalEntities = this.saveBundle.entities;
    }

    private prepareAddChangeSet(entity: Entity, index: number): Promise<SaveResult> {
        const defaultHeaders = {};
        Object.assign(defaultHeaders, this.headers);
        let rawEntity: any;
        const url = this.saveContext.dataService.qualifyUrl(this.saveContext.resourceName);
        const em = this.saveContext.entityManager;
        const et = entity.entityType;
        const aspect = entity.entityAspect;
        const helper = em.helper;

        if (!et.defaultResourceName) {
            throw new Error(`Missing resource name for type: ${et.name}`);
        }

        if (et.autoGeneratedKeyType !== AutoGeneratedKeyType.None) {
            this.saveContext.tempKeys[index] = aspect.getKey();
        }

        rawEntity = helper.unwrapInstance(entity, this.normalizeSaveValue);

        rawEntity.__metadata = {
            type: this.utils.clientTypeNameToServer(et.shortName)
        };

        const payload = JSON.stringify(rawEntity);


        return new Promise<SaveResult>((resolve, reject) => {

            function success(response: HttpResponse): void {
                response.saveContext = this.saveContext;
                const data = this.utils.unwrapInstance(response.data);

                if (data && (data.Error || data.error)) {
                    this.utils.handleHttpErrors(reject, response);
                } else {
                    const saveResult = this.makeSaveResult(response, index);
                    resolve(saveResult);
                }
            }

            function failed(response: HttpResponse): void {
                response.saveContext = this.saveContext;
                this.handleHttpErrors(reject, response);
            }
            const requestCfg = {
                url: url + et.defaultResourceName,
                type: 'POST',
                data: payload,
                headers: defaultHeaders,
                success: (response: HttpResponse) => success(response),
                error: (response: HttpResponse) => failed(response)
            };

            this.utils.ajaxAdapter.ajax(requestCfg);
        });
    }

    private normalizeSaveValue(prop: DataProperty, val: any): any {
        if (prop.isUnmapped) {
            return undefined;
        }
        if (prop.dataType === DataType.DateTimeOffset) {
            val =
                val &&
                new Date(val.getTime() - val.getTimezoneOffset() * 60000);
        } else if (prop.dataType.quoteJsonOData) {
            val = val != null ? val.toString() : val;
        }
        return val;
    }

    save(headers: Object): Promise<SaveResult> {
        this.headers = headers;
    }
}