import { Injectable } from '@angular/core';

import {
    SaveResult,
    JsonResultsAdapter,
    DataType,
    AutoGeneratedKeyType,
    EntityAspect,
    EntityType,
    EntityKey,
    Entity,
    config,
    SaveContext,
    MappingContext,
    MetadataStore,
    EntityState,
    SaveBundle,
    NodeContext
} from 'breeze-client';

interface ISaveRequest {
    requestUri?: string;
    method?: 'POST' | 'GET' | 'DELETE';
    data?: string;
    headers?: {[key: string]: string};
}

interface ISaveChngePackage extends SaveResult {
    originalEntities?: Entity[];
    index?: number;
    tempKeys?: EntityKey[];
    requests?: ISaveRequest[];
    response?: {
        status?: string,
        statusText?: string,
    };
    saveResult?: {
        XHR: any;
        entities: Entity[],
        entitiesWithErrors: {
            entity: Entity,
            error: any
        }[],
        keyMappings: any[]
    };
}

@Injectable({ providedIn: 'root' })
export class SpDataserviceAdapter {
    ajaxImpl: any;
    name: string;
    requestDigest: string;
    defaultHeaders: { [index: string]: string }
    dataServiceVersion: string;
    ignoreDeleteNotFound = true; // true if should ignore a 404 error from a delete
    jsonResultsAdapter: JsonResultsAdapter;
    typeMap: Object;

    constructor() {
        this.name = 'SpCustomOData';
        this.dataServiceVersion = '3.0';
        this.jsonResultsAdapter = new JsonResultsAdapter({
            name: `${this.name}_default`,
            visitNode: this.visitNode
        });
        this.defaultHeaders = {
            Accept: 'application/json;odata=verbose',
            DataServiceVersion: this.dataServiceVersion,
            'Content-Type': 'application/json;odata=verbose'
        }
        this.jsonResultsAdapter['serverTypeNameToClient'] = this.serverTypeNameToClient;
        this.jsonResultsAdapter['clientTypeNameToServer'] = this.clientTypeNameToServer;
        this.jsonResultsAdapter['typeMap'] = { '': { _mappedPropertiesCount: NaN } };
        SpDataserviceAdapter.prototype.jsonResultsAdapter = this.jsonResultsAdapter;
    }

    private addDigestToHeader(): void {
        if (this.requestDigest && !this.defaultHeaders['X-RequestDigest']) {
            this.defaultHeaders['X-RequestDigest'] = this.requestDigest;
        } else if (!this.requestDigest) {
            delete this.defaultHeaders['X-RequestDigest'];
        }
    }

    private addKeyMapping(savePackage: ISaveChngePackage, index: number, saved: any): void {
        const tempKey = savePackage.tempKeys[index];
        if (tempKey) {
            // entity had a temporary key; add a temp-to-perm key mapping
            const entityType = tempKey.entityType;
            const tempValue = tempKey.values[0];
            const realKey = this.getRealKey(entityType, saved);
            const keyMapping = {
                entityTypeName: entityType.name,
                tempValue: tempValue,
                realValue: realKey.values[0]
            };
            savePackage.saveResult.keyMappings.push(keyMapping);
        }
    }


    private catchNoConnectionError(error): void {
        if (error.status === 0 && error.message == null) {
            error.message = 'HTTP response status 0 and no message.  ' +
                'Likely did not or could not reach server. Is the server running?';
        }
    }

    private changeRequestSucceeded(savePackage: ISaveChngePackage, response: any, index: number): Entity {
        let saved = this.getResponseData(response);

        if (saved && typeof saved === 'object') {
            // Have "saved entity" data; add its type (for JsonResultsAdapter) & KeyMapping
            saved.$entityType = savePackage.originalEntities[index].entityType;
            this.addKeyMapping(savePackage, index, saved);
        } else {
            // No "saved entity" data; return the original entity
            saved = savePackage.originalEntities[index];
        }

        savePackage.saveResult.entities.push(saved);
        return saved;
    }

    clientTypeNameToServer(clientTypeName): string {
        return `SP.Data.${clientTypeName}ListItem`;
    }

    private createChangeRequest(saveContext: SaveContext, entity: Entity, savePackage: ISaveChngePackage): ISaveRequest {

        let request: ISaveRequest;
        let rawEntity: any;
        const entityManager = saveContext.entityManager as any;
        const helper = entityManager.helper;
        this.addDigestToHeader();

        const aspect = entity.entityAspect;
        const metadata = aspect.extraMetadata as any;
        const state = aspect.entityState;
        const type = entity.entityType;

        switch (state) {

            case EntityState.Added:
                if (!type.defaultResourceName) {
                    throw new Error(`Missing defaultResourceName for type ${type.name}`);
                }

                if (type.autoGeneratedKeyType !== AutoGeneratedKeyType.None) {
                    savePackage.tempKeys[savePackage.index] = aspect.getKey();
                }

                rawEntity = helper.unwrapInstance(entity, this.transformSaveValue);

                rawEntity.__metadata = { type: this.clientTypeNameToServer(type.shortName) };

                const data = JSON.stringify(rawEntity);

                request = {
                    requestUri: entityManager.dataService.serviceName + type.defaultResourceName,
                    method: 'POST',
                    data: data,
                    headers: this.defaultHeaders
                };
                break;

            case EntityState.Deleted:
                request = {
                    method: 'DELETE',
                    data: null
                };

                if (!metadata) {
                    throw new Error('Missing the extra metadata for an update/delete entity');
                }

                if (metadata.etag) {
                    Object.assign(request.headers, this.defaultHeaders);
                    request.headers['If-Match'] = metadata.etag;
                }

                request.requestUri = metadata.uri || metadata.id;
                break;

            case EntityState.Modified:
                request = {
                    method: 'POST'
                };

                if (metadata.etag) {
                    Object.assign(request.headers, this.defaultHeaders);
                    request.headers['If-Match'] = metadata.etag;
                 }
 
                request.headers['X-HTTP-Method'] = 'MERGE';
                rawEntity = helper.unwrapChangedValues(entity, entityManager.metadataStore, this.transformSaveValue);
                rawEntity.__metadata = { type: metadata.type };
                request.data = JSON.parse(rawEntity);
                break;

            default:
                throw new Error(`Cannot save an entity whose EntityState is ${state.getName()}`);
        }

        return request;
    }

    /** Create error object for both query and save responses.
     * A method on the adapter (`this`) 'context' can help differentiate query and save
     * 'errorEntity' only defined for save response
     */
    private createErrorFromResponse(response: any, url: string): any {
        // OData errors can have the message buried very deeply - and nonobviously
        // this code is tricky so be careful changing the response.body parsing.
        const err = new Error() as any;
        err.response = response;
        if (url) { err.url = url; }
        err.message = response.message || response.error || response.statusText;
        err.statusText = response.statusText;
        err.status = response.status;
        this.setSPODataErrorMessage(err);
        this.catchNoConnectionError(err);
        return err;
    }

    executeQuery(mappingContext: MappingContext): Promise<QueryResult> {
        const query = mappingContext.query;
        const entityType = this._getEntityTypeFromMappingContext(mappingContext);
        // @ts-ignore
        const custom = (entityType && entityType.custom) || {} as any;

        // @ts-ignore
        if (!query.selectClause && entityType && custom.defaultSelect) {
            mappingContext.query = query.select(custom.defaultSelect);
        }

        this.addDigestToHeader();

        const httpOptions = {
            type: 'GET',
            url: mappingContext.getUrl(),
            headers: this.defaultHeaders,
            params: query.parameters,
            dataType: 'json',
            success: null,
            error: null
        };
        return new Promise((resolve, reject) => {
            httpOptions.success = (response) => {
                const data = response.data;
                const inlineCount = data.__count ? parseInt(data.__count, 10) : undefined;
                const result = this.getResponseData(response);
                resolve({ results: result, inlineCount: inlineCount, httpResponse: response } as QueryResult);

            };
            httpOptions.error = (response) => {
                const error = this.createErrorFromResponse(response, mappingContext.getUrl());
                reject(error);

            };
            // tslint:disable-next-line:no-unused-expression
            this.ajaxImpl.ajax(httpOptions) as any;
        });
    }

    fetchMetadata(metadataStore: MetadataStore, dataService: any): Promise<any> {
        return Promise.reject(new Error('Fetch Metadata is not available on this adapter;'));
    }

    private getRealKey(entityType: EntityType, rawEntity: any): EntityKey {
        // @ts-ignore
        return entityType.getEntityKeyFromRawEntity(rawEntity, DataProperty.getRawValueFromServer);
    }

    private getResponseData(response: any) {
        const data = response.data && response.data.d;
        return data.results === undefined ? data : data.results;
    }

    private _getEntityTypeFromMappingContext(mc: MappingContext): EntityType {
        const query = mc.query;
        if (!query || typeof query === 'string') { return null; }
        let entityType = query.resultEntityType as EntityType;
        if (!entityType) {
            const etName = mc.metadataStore.getEntityTypeNameForResourceName(query.resourceName);
            if (etName) {
                entityType = mc.metadataStore.getEntityType(etName) as EntityType;
            }
        }
        return entityType;
    }

    _getResponseData(response): any {
        const data = response.data && response.data.d;
        return data.results === undefined ? data : data.results;
    }

    initialize(): void {
        this.ajaxImpl = config.getAdapterInstance('ajax');

        // don't cache 'ajax' because then we would need to ".bind" it, and don't want to because of brower support issues.
        if (this.ajaxImpl && this.ajaxImpl.ajax) {  return; }
        throw new Error(`Unable to find ajax adapter for dataservice adapter (this.name || '')`);
    }

    private processSavedEntity(savedEntity: Entity, response: any): void {
        const etag = savedEntity && savedEntity.entityAspect && response.getHeaders('ETag');
        if (etag) {

            // @ts-ignore
            savedEntity.entityAspect.extraMetadata.etag = etag;
        }
    }

    saveChanges(saveContext: SaveContext, saveBundle: SaveBundle): Promise<SaveResult> {
        const savePackage = {} as ISaveChngePackage;
        savePackage.originalEntities = saveBundle.entities;
        savePackage.tempKeys = [];
        savePackage.saveResult = {
            entities: [],
            XHR: null,
            entitiesWithErrors: [],
            keyMappings: []
        };

        savePackage.requests = saveBundle.entities.map((entity, index) => {
            savePackage.index = index;
            return this.createChangeRequest(saveContext, entity, savePackage);
        });
        const savePromises = this.sendChangeRequests(savePackage);
        return new Promise(async (resolve, reject) => {
            try {
                await Promise.all(savePromises);
            } catch (e) {
               return reject(e);
            }
            const saveResult = this.reviewSaveResult(saveContext, savePackage, savePackage.requests);
            if (saveResult.meessage) {
                return reject(saveResult);
            }
            return resolve(saveResult);
        });
    }

    private reviewSaveResult(saveContext: SaveContext, savedPackage: ISaveChngePackage, requests: any[]): ISaveChngePackage| any {
        if (!savedPackage.saveResult.entitiesWithErrors.length) { return savedPackage; }
        const saveResult = savedPackage.saveResult;
        const entitiesWithError = saveResult.entitiesWithErrors;
        const errorCount = entitiesWithError.length;
        saveContext.processSavedEntities(saveResult);

        let error;

        if (requests.length === 1 || requests.length === errorCount) {
            error = entitiesWithError[0].error;
        } else {
            error = new Error('\n The save failed although some entities were saved.');
        }

        error.message = `${(error.message || 'Saved failed')} \n See 'error.saveResult' for more details.\n`;
        error.saveResult = saveResult;
        return Promise.reject(error);
    }

    sendChangeRequests(savePackage: ISaveChngePackage): Promise<any>[] {

        return savePackage.requests.map(async (request, index) => {
            const httpOptions = {
                url: request.requestUri,
                type: request.method,
                headers: request.headers,
                data: request.data,
                success: null,
                error: null
            };
            const reqPromise = new Promise(async (resolve, reject) => {
                try {
                    httpOptions.success = resolve;
                    httpOptions.error = reject;
                    const response = await this.ajaxImpl.ajax(httpOptions) as any;
                    this.tryRequestSucceeded(response, index, request, savePackage);
                } catch (e) {
                    Promise.reject('Program error: failed while processing successful save response');
                }
            });
            return reqPromise;
        });
    }

    setSPODataErrorMessage(err): void {
        // OData errors can have the message buried very deeply - and nonobviously
        // Normal MS OData responses have a response.body
        // SharePoint OData responses have a response.data instead
        // this code is tricky so be careful changing the response.data parsing.
        let data = err.data = err.response.data;
        let m;
        const msg = [];
        let nextErr;

        if (data) {
            try {
                if (typeof data === 'string') {
                    data = err.data = JSON.parse(data);
                }
                do {
                    nextErr = data.error || data.innererror;
                    if (!nextErr) {
                        m = data.message || '';
                        msg.push((typeof m === 'string') ? m : m.value);
                    }
                    nextErr = nextErr || data.internalexception;
                    data = nextErr;
                } while (nextErr);
                if (msg.length > 0) {
                    err.message = msg.join('; ') + '.';
                }
            } catch (e) { /* carry on */ }
        }
    }

    serverTypeNameToClient(serverTypeName) {
        const re = /^(SP\.Data.)(.*)(ListItem)$/;
        const typeName = serverTypeName.replace(re, '$2');
        return MetadataStore.normalizeTypeName(typeName);
    }

    private transformSaveValue(prop, val) {
        // prepare a property value for save by transforming it
        // ref: breeze.labs.dataservice.abstract.js
        if (prop.isUnmapped) { return undefined; }
        if (prop.dataType === DataType.DateTimeOffset) {
            val = val && new Date(val.getTime() - (val.getTimezoneOffset() * 60000));
        } else if (prop.dataType.quoteJsonOData) {
            val = val != null ? val.toString() : val;
        }
        return val;
    }

    private tryRequestFailed(response: any, index: number, request: ISaveRequest, savePackage: ISaveChngePackage) {
        const serverResponseCode = +response.status;

        if (serverResponseCode &&
            serverResponseCode === 404 &&
            this.ignoreDeleteNotFound &&
            savePackage.originalEntities[index].entityAspect.entityState.isDeleted()
        ) {
            // deleted entity not found; treat as if successfully deleted.
            response.status = 204;
            response.statusText = 'resource was already deleted; no content';
            response.data = undefined;
            this.tryRequestSucceeded(response, index, request, savePackage);
        } else {
            // Do NOT fail saveChanges at the request level
            const errorEntity = savePackage.originalEntities[index];
            savePackage.saveResult.entitiesWithErrors.push({
                entity: errorEntity,
                error: this.createErrorFromResponse(response, request.requestUri)
            });
            Promise.resolve(false);
        }
    }

    private tryRequestSucceeded(response: any, index: number, request: any, savePackage: ISaveChngePackage) {
        try {
            const serverResponseCode = +response.status;
            if ((!serverResponseCode) || serverResponseCode >= 400) {
                this.tryRequestFailed(response, index, request, savePackage);
            } else {
                const savedEntity = this.changeRequestSucceeded(savePackage, response, index);
                this.processSavedEntity(savedEntity, response);
                Promise.resolve(true);
            }
        } catch (e) {
            Promise.reject('Program error: failed while processing successful save response');
        }
    }

    visitNode(node: any, mappingContext: MappingContext, nodeContext: NodeContext): any {
        const result = { ignore: true, node: undefined, entityType: undefined, extraMetadata: undefined };

        if (!node) { return result; }

        const propertyName = nodeContext.propertyName;
        const ignoreNode = node.__deferred != null || propertyName === '__metadata';
        // (propertyName === "EntityKey" && node.$type && core.stringStartsWith(node.$type, "System.Data"));

        if (!ignoreNode) {
            result.ignore = false;
            if (!node.__metadata) { return result.node = node.results; }

            if (node.$entityType) {
                result.entityType = node.$entityType;
                result.extraMetadata = node.__metadata;
                return result.node = node.results;
            }
            const typeName = this.serverTypeNameToClient(node.__metadata.type);

            if (!typeName) { return; }

            let entityType = this.typeMap[typeName] as EntityType | any;

            if (!entityType) {
                entityType = mappingContext.metadataStore.getEntityType(typeName, true) as EntityType;
                this.typeMap[typeName] = entityType || this.typeMap[''];
            }

            if (!entityType) { return; }

            if ((entityType._mappedPropertiesCount - entityType.navigationProperties.length) <= Object.keys(node).length - 1) {
                result.entityType = entityType;
                result.extraMetadata = node.__metadata;
            }
        }
        return result;
    }
}
config.registerAdapter('dataService', SpDataserviceAdapter);
