import {
    DataProperty, AutoGeneratedKeyType, NavigationProperty, DataType
} from 'breeze-client';

import pluralize = require('pluralize');

export class TypeDefintion {
    private _typeDef: TypeDefintion;u
    autoGeneratedKeyType: AutoGeneratedKeyType;
    dataProperties: { [index: string]: DataProperty };
    navigationProperties: { [index: string]: NavigationProperty };
    defaultResourceName: string;
    isComplexType: boolean;

    name: string;
    shortName: string;
    namespace: string;
    private typeName: string;

    constructor(td: TypeDefintion, tdNamespace: string) {
        this._typeDef = td;
        this.typeName = td.shortName;
        this.namespace = tdNamespace;
    }

    private removeAttribute(prop = this._typeDef as Object, oldName: string, newName: string): TypeDefintion {
        if (prop[newName] !== undefined) {
            throw new Error(`renameAttrib error; new name: ${newName} is already defined on object`);
        }
        prop[newName] = prop[oldName];
        delete prop[oldName];
        return this;
    }

    private normalizeNavProp(key: string, prop: string | Object): any {
        switch (typeof (prop)) {
            case 'string':
                return { entityTypeName: prop };
            case 'object':
                return prop;
            default:
                // nav prop name (key) is same as EntityName (PascalCased)
                const ename = key.substr(0, 1).toUpperCase() + key.substr(1);
                return { entityTypeName: ename };
        }
    }

    checkForName(): TypeDefintion {
        if (this._typeDef.name) {
            this._typeDef.removeAttribute(undefined, 'name', 'shortName')
        }
        return this;
    }

    hasAKeyType(defaultKeyGenType: AutoGeneratedKeyType): TypeDefintion {
        if (this._typeDef.isComplexType) { return this; }
        this._typeDef.autoGeneratedKeyType = this._typeDef.autoGeneratedKeyType || defaultKeyGenType;
        return this;
    }

    inferDefaultResourceName(): TypeDefintion {
        if (this._typeDef.isComplexType) { return this; }

        if (this._typeDef.defaultResourceName === undefined) {
            this._typeDef.defaultResourceName = pluralize(this._typeDef.shortName);
        }
        return this;
    }

    findEntityKey(): TypeDefintion {
        if (this._typeDef.isComplexType) { return this; }
        const dps = this._typeDef.dataProperties;
        const typeNameId = this._typeDef.shortName.toLowerCase() + 'id';
        for (const key of Object.keys(dps)) {
            const prop = dps[key];
            // found a key part; stop analysis
            if (prop.isPartOfKey) { return; }

            // if type were Person, would look for 'id' or 'personid'
            if (!prop.isPartOfKey) {
                // isPartOfKey is null or undefined; is it a candidate?
                const keyLc = key.toLowerCase();
                if (keyLc === 'id' || keyLc === typeNameId) {
                    // infer this property is the key; stop further analysis
                    prop.isPartOfKey = true;
                }
            }
        }
        return this;
    }

    setNamespace(defaultNamespace: string): TypeDefintion {
        this.namespace = this.namespace || defaultNamespace;
        return this;
    }

    replaceDataPropAliases(): TypeDefintion {

        for (const key of Object.keys(this._typeDef.dataProperties)) {
            const keyLc = key.toLowerCase();
            const prop = this._typeDef.dataProperties[key];

            if (keyLc === 'type') {
                this.removeAttribute(this._typeDef.dataProperties, key, 'dataType');
            } else if (keyLc === 'complex' || keyLc === 'complextype') {
                this.removeAttribute(this._typeDef.dataProperties, key, 'complexTypeName');
            } else if (keyLc === 'max' && (prop.dataType === undefined || prop.dataType === DataType.String)) {
                this.removeAttribute(this._typeDef.dataProperties, key, 'maxLength');
            } else if (keyLc.indexOf('null') > -1 && key !== 'isNullable' && typeof (prop[key]) === 'boolean') {
                this.removeAttribute(this._typeDef.dataProperties, key, 'isNullable');
            } else if (keyLc === 'required') {
                prop[key] = !prop[key];
                this.removeAttribute(this._typeDef.dataProperties, key, 'isNullable');
            } else if (keyLc.indexOf('key') > -1 && key !== 'isPartOfKey' && typeof (prop[key]) === 'boolean') {
                this.removeAttribute(this._typeDef.dataProperties, key, 'isPartOfKey');
            } else if (keyLc === 'default') {
                this.removeAttribute(this._typeDef.dataProperties, key, 'defaultValue');
            } else if (keyLc === 'isone' || keyLc === 'hasone') {
                this.removeAttribute(this._typeDef.dataProperties, key, 'isScalar');
            // Mongo subdocuments could be collections of complex types
            } else if (keyLc === 'ismany' || keyLc === 'hasmany') {
                prop[key] = !prop[key];
                this.removeAttribute(this._typeDef.dataProperties, key, 'isScalar');
            }

            if (prop.complexTypeName && prop.complexTypeName.indexOf(':#') === -1) {
                // if complexTypeName is unqualified, suffix with the entity's own namespace
                prop.complexTypeName += ':#' + this.namespace;
            }
        }
        return this;
    }
    /*
     *  Support common aliases in Navigation Property attributes to reduce tedium
     *  type -> entityTypeName
     *  FK|FKs -> foreignKeyNames
     *  invFK|invFKs -> invForeignKeyNames
     *  assoc -> associationName
     *  isOne | hasOne -> isScalar
     *  isMany | hasMany -> isScalar with boolean flipped
     */
    replaceNavPropAliases(): TypeDefintion {
        for (const key of Object.keys(this._typeDef.navigationProperties)) {
            const keyLc = key.toLowerCase();
            const prop =
                this._typeDef.navigationProperties[key] =
                this.normalizeNavProp(key, this._typeDef.navigationProperties[key]) as NavigationProperty;
            switch (keyLc) {
                case 'type':
                    this.removeAttribute(this._typeDef.navigationProperties, key, 'entityTypeName');
                    break;
                case 'fk':
                case 'fks':
                case 'key':
                    this.removeAttribute(this._typeDef.navigationProperties, key, 'foreignKeyNames');
                    break;
                case 'isone':
                case 'hasone':
                    this.removeAttribute(this._typeDef.navigationProperties, key, 'isScalar');
                    break;
                case 'ismany':
                case 'hasmany':
                    prop[key] = !prop[key];
                    this.removeAttribute(this._typeDef.navigationProperties, key, 'isScalar');
                    break;
                case 'invfk':
                case 'invfks':
                    this.removeAttribute(this._typeDef.navigationProperties, key, 'invForeignKeyNames');
                    break;
                default:
                    if (keyLc.indexOf('assoc') > -1 && key !== 'associationName') {
                        this.removeAttribute(this._typeDef.navigationProperties, key, 'associationName');
                    }
            }

            let propTypeName = prop.entityTypeName;

            // append the namespace to entityTypeName if missing
            const nsStart = propTypeName.indexOf(':#');
            if (nsStart === -1) {
                // name is unqualified; append the namespace
                prop.entityTypeName += ':#' + this.namespace;
            } else {
                propTypeName = propTypeName.slice(0, nsStart);
            }

            // Infer that it's a child nav if no FKs, no invFKs, and not a collection
            if (prop.foreignKeyNames === undefined && prop.isScalar !== false &&
                prop.invForeignKeyNames === undefined) {
                // Look for candidate FK property among the data properties as
                // (1) propertyname + id OR (2) unqualified typename + 'id'
                const candidate1 = key.toLowerCase() + 'id';
                const candidate2 = propTypeName.toLowerCase() + 'id';
                const fk = Object.keys(this._typeDef.dataProperties).filter(
                    function (k) {
                        k = k.toLowerCase();
                        return k === candidate1 || k === candidate2;
                    })[0];
                if (fk) { prop.foreignKeyNames = [fk]; }
            }

            if (prop.associationName === undefined) {
                const isParent = prop.isScalar === false ||
                               prop.invForeignKeyNames ||
                               prop.foreignKeyNames === undefined;
                // association name is 'ChildType_ParentType'
                prop.associationName =
                    (isParent ? propTypeName : this.typeName) + '_' +
                    (isParent ? this.typeName : propTypeName);
            }

            // coerce FK names to array
            let keyNames = prop.foreignKeyNames;
            if (keyNames && !Array.isArray(keyNames)) {
                prop.foreignKeyNames = [keyNames];
            }
            keyNames = prop.invForeignKeyNames;
            if (keyNames && !Array.isArray(keyNames)) {
                prop.invForeignKeyNames = [keyNames];
            }

        }
        return this;
    }
}
