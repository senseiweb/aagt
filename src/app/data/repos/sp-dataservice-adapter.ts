import { Injectable } from '@angular/core';
import * as breeze from 'breeze-client';
import 'breeze-client-labs/breeze.namingConventionWithDictionary';
import { AjaxHttpClientAdapter } from 'breeze-bridge2-angular';

interface ISaveRequest {
    requestUri?: string;
    method?: 'POST' | 'GET' | 'DELETE';
    data?: string;
    headers?: string;
}

interface ISaveChngePackage {
    originalEntities?: breeze.Entity[];
    index?: number;
    tempKeys?: breeze.EntityKey[];
    requests?: ISaveRequest[];
    response?: {
        status?: string,
        statusText?: string,
    };
    saveResult?: {
        entities: breeze.Entity[],
        entitiesWithErrors: {
            entity: breeze.Entity,
            error: any
        }[],
        keyMappings: any[]
    };
}

@Injectable({ providedIn: 'root' })
export class SpDataserviceAdapter {
    ajaxImpl: AjaxHttpClientAdapter;
    name: string;
    getRequestDigest: Function;
    dataServiceVersion: string;
    ignoreDeleteNotFound = true; // true if should ignore a 404 error from a delete
    jsonResultsAdapter = new breeze.JsonResultsAdapter({
        name: `${this.name}_default`,
        visitNode: this.visitNode
    });
    private typeMap = {
        '': { _mappedPropertiesCount: NaN }
    };

    constructor() {
        this.name = 'SpCustomOData';
        this.dataServiceVersion = '3.0';
    }

    private addKeyMapping(savePackage: ISaveChngePackage, index: number, saved: any): void {
        const tempKey = savePackage.tempKeys[index];
        if (tempKey) {
            // entity had a temporary key; add a temp-to-perm key mapping
            const entityType = tempKey.entityType;
            const tempValue = tempKey.values[0];
            const realKey = this.getRealKey(entityType, saved);
            const keyMapping = {
                entityTypeName: entityType.name,
                tempValue: tempValue,
                realValue: realKey.values[0]
            };
            savePackage.saveResult.keyMappings.push(keyMapping);
        }
    }

    private adjectUpdateDeleteRequest(aspect: breeze.EntityAspect): string {
        if (!aspect.extraMetadata) {
            throw new Error('Missing the extra metadata for an update/delete entity');
        }
        if (aspect.extraMetadata.etag) {
            this.getHttpHeaders()['If-Match'] = aspect.extraMetadata.etag;
        }
        return aspect.extraMetadata.uri || aspect.extraMetadata.id;
    }

    private catchNoConnectionError(error): void {
        if (error.status === 0 && error.message == null) {
            error.message = 'HTTP response status 0 and no message.  ' +
                'Likely did not or could not reach server. Is the server running?';
        }
    }

    private changeRequestSucceeded(savePackage: ISaveChngePackage, response: any, index: number): breeze.Entity {
        let saved = this.getResponseData(response);

        if (saved && typeof saved === 'object') {
            // Have "saved entity" data; add its type (for JsonResultsAdapter) & KeyMapping
            saved.$entityType = savePackage.originalEntities[index].entityType;
            this.addKeyMapping(savePackage, index, saved);
        } else {
            // No "saved entity" data; return the original entity
            saved = savePackage.originalEntities[index];
        }

        savePackage.saveResult.entities.push(saved);
        return saved;
    }

    clientTypeNameToServer(clientTypeName): string {
        return `SP.Data.${clientTypeName}.Item`;
    }

    private createChangeRequest(saveContext: breeze.SaveContext, entity: breeze.Entity, savePackage: ISaveChngePackage): ISaveRequest {

        let request: ISaveRequest;
        let rawEntity: any;
        const entityManager = saveContext.entityManager;
        const helper = entityManager.helper;

        const aspect = entity.entityAspect;
        const state = aspect.entityState;
        const type = entity.entityType;

        switch (state) {

            case breeze.EntityState.Added:
                if (!type.defaultResourceName) {
                    throw new Error(`Missing defaultResourceName for type ${type.name}`);
                }

                if (type.autoGeneratedKeyType !== breeze.AutoGeneratedKeyType.None) {
                    savePackage.tempKeys[savePackage.index] = aspect.getKey();
                }

                rawEntity = helper.unwrapInstance(entity, this.transformSaveValue);

                rawEntity.__metadata = { type: this.clientTypeNameToServer(type.shortName) };

                const data = JSON.stringify(rawEntity);

                request = {
                    requestUri: entityManager.dataService.serviceName + type.defaultResourceName,
                    method: 'POST',
                    data: data,
                };
                break;

            case breeze.EntityState.Deleted:
                request = {
                    method: 'DELETE',
                    data: null
                };

                request.requestUri = this.adjectUpdateDeleteRequest(aspect);
                break;

            case breeze.EntityState.Modified:
                request = {
                    method: 'POST'
                };
                this.adjectUpdateDeleteRequest(aspect);
                request.headers = this.getHttpHeaders()['X-HTTP-Method'] = 'MERGE';
                rawEntity = helper.unwrapChangedValues(entity, entityManager.metadataStore, this.transformSaveValue);
                rawEntity.__metadata = { type: aspect.extraMetadata.type };
                request.data = JSON.parse(rawEntity);
                break;

            default:
                throw new Error(`Cannot save an entity whose EntityState is ${state.getName()}`);
        }

        return request;
    }

    /** Create error object for both query and save responses.
     * A method on the adapter (`this`) 'context' can help differentiate query and save
     * 'errorEntity' only defined for save response
     */
    private createErrorFromResponse(response: any, url: string): any {
        // OData errors can have the message buried very deeply - and nonobviously
        // this code is tricky so be careful changing the response.body parsing.
        const err = new Error() as any;
        err.response = response;
        if (url) { err.url = url; }
        err.message = response.message || response.error || response.statusText;
        err.statusText = response.statusText;
        err.status = response.status;
        this.setSPODataErrorMessage(err);
        this.catchNoConnectionError(err);
        return err;
    }

    executeQuery(mappingContext: breeze.MappingContext): Promise<QueryResult> {
        const query = mappingContext.query as breeze.EntityQuery;

        const entityType = this._getEntityTypeFromMappingContext(mappingContext);
        const custom = entityType.custom || {} as any;

        if (!query.selectClause && entityType && custom.defaultSelect) {
            mappingContext.query = query.select(custom.defaultSelect);
        }

        const httpOptions = {
            type: 'GET',
            url: mappingContext.getUrl(),
            headers: this.getHttpHeaders(),
            params: query.parameters,
            dataType: 'json',
            success: null,
            error: null
        };
        return new Promise(async (resolve, reject) => {
            httpOptions.success = resolve;
            httpOptions.error = reject;
            try {
                const response = await this.ajaxImpl.ajax(httpOptions) as any;
                const data = response.data;
                const inlineCount = data.__count ? parseInt(data.__count, 10) : undefined;
                const result = this.getResponseData(response);
                resolve({ results: result, inlineCount: inlineCount, httpResponse: response } as QueryResult);
            } catch (response) {
                const error = this.createErrorFromResponse(response, mappingContext.getUrl());
                reject(error);
            }
        });
    }

    fetchMetadata(metadataStore: breeze.MetadataStore, dataService: any): Promise<any> {
        return Promise.reject(new Error('Fetch Metadata is not available on this adapter;'));
    }

    private getRealKey(entityType: breeze.EntityType, rawEntity: any): breeze.EntityKey {
        return entityType.getEntityKeyFromRawEntity(rawEntity, breeze.DataProperty.getRawValueFromServer);
    }

    private getResponseData(response: any) {
        const data = response.data && response.data.d;
        return data.results === undefined ? data : data.results;
    }

    private _getEntityTypeFromMappingContext(mc: breeze.MappingContext): breeze.EntityType {
        const query = mc.query;
        if (!query || typeof query === 'string') { return null; }
        let entityType = query.resultEntityType as breeze.EntityType;
        if (!entityType) {
            const etName = mc.metadataStore.getEntityTypeNameForResourceName(query.resourceName);
            if (etName) {
                entityType = mc.metadataStore.getEntityType(etName) as breeze.EntityType;
            }
        }
        return entityType;
    }

    _getResponseData(response): any {
        const data = response.data && response.data.d;
        return data.results === undefined ? data : data.results;
    }

    private getHttpHeaders = () => {
        const basicHeaders = {
            Accept: 'application/json;odata=verbose',
            DataServiceVersion: this.dataServiceVersion,
            'Content-Type': 'application/json;odata=verbose',
            'If-Match': undefined
        };
        if (this.getRequestDigest) {
            basicHeaders['X-RequestDigest'] = this.getRequestDigest();
        }
        return basicHeaders;
    }

    initialize(): void {
        // this.ajaxImpl = config.getAdapterInstance('ajax');
        // // don't cache 'ajax' because then we would need to ".bind" it, and don't want to because of brower support issues.
        // if (this.ajaxImpl && this.ajaxImpl.ajax) {
        //     return;
        // }
        // throw new Error(`Unable to find ajax adapter for dataservice adapter (this.name || '')`);
    }

    private processSavedEntity(savedEntity: breeze.Entity, response: any): void {
        const etag = savedEntity && savedEntity.entityAspect && response.getHeaders('ETag');
        if (etag) {
            savedEntity.entityAspect.extraMetadata.etag = etag;
        }
    }

    saveChanges(saveContext: breeze.SaveContext, saveBundle: breeze.SaveBundle): Promise<breeze.SaveResult> {
        const savePackage = {} as ISaveChngePackage;
        savePackage.originalEntities = saveBundle.entities;
        savePackage.tempKeys = [];
        savePackage.saveResult = {
            entities: [],
            entitiesWithErrors: [],
            keyMappings: []
        };

        savePackage.requests = saveBundle.entities.map((entity, index) => {
            savePackage.index = index;
            return this.createChangeRequest(saveContext, entity, savePackage);
        });
        const savePromises = this.sendChangeRequests(savePackage);
        return new Promise(async (resolve) => {
            try {
                await Promise.all(savePromises);
                this.reviewSaveResult(saveContext, savePackage, savePackage.requests);
                resolve();
            } catch (e) {
                Promise.reject(e);
            }
        });
    }

    private reviewSaveResult(saveContext: breeze.SaveContext, savedPackage: ISaveChngePackage, requests: any[]): ISaveChngePackage| any {
        if (!savedPackage.saveResult.entitiesWithErrors.length) { return savedPackage; }
        const saveResult = savedPackage.saveResult;
        const entitiesWithError = saveResult.entitiesWithErrors;
        const errorCount = entitiesWithError.length;
        saveContext.processSavedEntities(saveResult);

        let error;

        if (requests.length === 1 || requests.length === errorCount) {
            error = entitiesWithError[0].error;
        } else {
            error = new Error('\n The save failed although some entities were saved.');
        }

        error.message = `${(error.message || 'Saved failed')} \n See 'error.saveResult' for more details.\n`;
        error.saveResult = saveResult;
        return Promise.reject(error);
    }

    sendChangeRequests(savePackage: ISaveChngePackage): Promise<any>[] {

        return savePackage.requests.map(async (request, index) => {
            const httpOptions = {
                url: request.requestUri,
                type: request.method,
                headers: request.headers,
                data: request.data,
                success: null,
                error: null
            };
            const reqPromise = new Promise(async (resolve, reject) => {
                try {
                    httpOptions.success = resolve;
                    httpOptions.error = reject;
                    const response = await this.ajaxImpl.ajax(httpOptions) as any;
                    this.tryRequestSucceeded(response, index, request, savePackage);
                } catch (e) {
                    Promise.reject('Program error: failed while processing successful save response');
                }
            });
            return reqPromise;
        });
    }

    setSPODataErrorMessage(err): void {
        // OData errors can have the message buried very deeply - and nonobviously
        // Normal MS OData responses have a response.body
        // SharePoint OData responses have a response.data instead
        // this code is tricky so be careful changing the response.data parsing.
        let data = err.data = err.response.data;
        let m;
        const msg = [];
        let nextErr;

        if (data) {
            try {
                if (typeof data === 'string') {
                    data = err.data = JSON.parse(data);
                }
                do {
                    nextErr = data.error || data.innererror;
                    if (!nextErr) {
                        m = data.message || '';
                        msg.push((typeof m === 'string') ? m : m.value);
                    }
                    nextErr = nextErr || data.internalexception;
                    data = nextErr;
                } while (nextErr);
                if (msg.length > 0) {
                    err.message = msg.join('; ') + '.';
                }
            } catch (e) { /* carry on */ }
        }
    }

    serverTypeNameToClient(serverTypeName) {
        const re = /^(SP\.Data.)(.*)(ListItem)$/;
        const typeName = serverTypeName.replace(re, '$2');
        return breeze.MetadataStore.normalizeTypeName(typeName);
    }

    private transformSaveValue(prop, val) {
        // prepare a property value for save by transforming it
        // ref: breeze.labs.dataservice.abstract.js
        if (prop.isUnmapped) { return undefined; }
        if (prop.dataType === breeze.DataType.DateTimeOffset) {
            val = val && new Date(val.getTime() - (val.getTimezoneOffset() * 60000));
        } else if (prop.dataType.quoteJsonOData) {
            val = val != null ? val.toString() : val;
        }
        return val;
    }

    private tryRequestFailed(response: any, index: number, request: ISaveRequest, savePackage: ISaveChngePackage) {
        const serverResponseCode = +response.status;

        if (serverResponseCode &&
            serverResponseCode === 404 &&
            this.ignoreDeleteNotFound &&
            savePackage.originalEntities[index].entityAspect.entityState.isDeleted()
        ) {
            // deleted entity not found; treat as if successfully deleted.
            response.status = 204;
            response.statusText = 'resource was already deleted; no content';
            response.data = undefined;
            this.tryRequestSucceeded(response, index, request, savePackage);
        } else {
            // Do NOT fail saveChanges at the request level
            const errorEntity = savePackage.originalEntities[index];
            savePackage.saveResult.entitiesWithErrors.push({
                entity: errorEntity,
                error: this.createErrorFromResponse(response, request.requestUri)
            });
            Promise.resolve(false);
        }
    }

    private tryRequestSucceeded(response: any, index: number, request: any, savePackage: ISaveChngePackage) {
        try {
            const serverResponseCode = +response.status;
            if ((!serverResponseCode) || serverResponseCode >= 400) {
                this.tryRequestFailed(response, index, request, savePackage);
            } else {
                const savedEntity = this.changeRequestSucceeded(savePackage, response, index);
                this.processSavedEntity(savedEntity, response);
                Promise.resolve(true);
            }
        } catch (e) {
            Promise.reject('Program error: failed while processing successful save response');
        }
    }

    visitNode(node: any, mappingContext: breeze.MappingContext, nodeContext: breeze.NodeContext): any {
        const result = { ignore: true, node: undefined, entityType: undefined, extraMetadata: undefined };

        if (!node) { return result; }

        const propertyName = nodeContext.propertyName;
        const ignoreNode = node.__deferred !== null || propertyName === '__metadata';

        if (!ignoreNode) {
            result.ignore = false;
            if (!node.__metadata) { return result.node = node.results; }

            if (node.$entityType) {
                result.entityType = node.$entityType;
                result.extraMetadata = node.__metadata;
                return result.node = node.results;
            }
            const typeName = this.serverTypeNameToClient(node.__metadata.type);

            if (!typeName) { return; }

            let entityType = this.typeMap[typeName] as breeze.EntityType | any;

            if (!entityType) {
                entityType = mappingContext.metadataStore.getEntityType(typeName, true) as breeze.EntityType;
                this.typeMap[typeName] = entityType || this.typeMap[''];
            }

            if (!entityType) { return; }

            if ((entityType._mappedPropertiesCount - entityType.navigationProperties) <= Object.keys(node).length - 1) {
                result.entityType = entityType;
                result.extraMetadata = node.__metadata;
            }
        }
    }
}
// @ts-ignore
breeze.config.registerAdapter('dataService', SpDataserviceAdapter);
