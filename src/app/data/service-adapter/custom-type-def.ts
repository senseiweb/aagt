import {
    DataProperty,
    AutoGeneratedKeyType,
    NavigationProperty,
    DataType,
    EntityType
} from 'breeze-client';

import * as pluralize from 'pluralize';
import { SpEntityBase, SpEntityDef, DataMembers, NavMembers, Omit } from '../models';

export declare type CustomEtDef = Omit<EntityType, 'dataProperties' | 'navigationProperties'>;

export class TypeDefintion<T> implements SpEntityDef<T> {
    autoGeneratedKeyType?: AutoGeneratedKeyType;
    dataProperties?: DataMembers<T>;
    navigationProperties?: NavMembers<T>;
    defaultResourceName?: string;
    isComplexType?: boolean;

    name: string;
    shortName: string;
    namespace: string;
    private typeName: string;

    constructor() {
        this.dataProperties = {} as any;
        this.navigationProperties = {} as any;
        this.shortName = '';
        this.defaultResourceName = '';
    }

    private removeAttribute(prop: Object, oldName: string, newName: string): TypeDefintion<any> {
        if (prop[newName] !== undefined) {
            throw new Error(`renameAttrib error; new name: ${newName} is already defined on object`);
        }
        prop[newName] = prop[oldName];
        delete prop[oldName];
        return this;
    }

    private normalizeNavProp(key: string, prop: string | Object): any {
        switch (typeof (prop)) {
            case 'string':
                return { entityTypeName: prop };
            case 'object':
                return prop;
            default:
                // nav prop name (key) is same as EntityName (PascalCased)
                const ename = key.substr(0, 1).toUpperCase() + key.substr(1);
                return { entityTypeName: ename };
        }
    }

    checkForName(): TypeDefintion<any>  {
        if (this.name) {
            this.removeAttribute(this.name, 'name', 'shortName')
        }
        return this;
    }

    hasAKeyType(defaultKeyGenType: AutoGeneratedKeyType): TypeDefintion<any>  {
        if (this.isComplexType) { return this; }
        this.autoGeneratedKeyType = this.autoGeneratedKeyType || defaultKeyGenType;
        return this;
    }

    inferDefaultResourceName(): TypeDefintion<any>  {
        if (this.isComplexType) { return this; }

        if (this.defaultResourceName === undefined) {
            this.defaultResourceName = pluralize(this.shortName);
        }
        return this;
    }

    findEntityKey(): TypeDefintion<any>  {
        if (this.isComplexType) { return this; }
        const dps = this.dataProperties;
        const typeNameId = this.shortName.toLowerCase() + 'id';
        for (const key of Object.keys(dps)) {
            const prop = dps[key];
            // found a key part; stop analysis
            if (prop.isPartOfKey) { break; }

            // if type were Person, would look for 'id' or 'personid'
            if (!prop.isPartOfKey) {
                // isPartOfKey is null or undefined; is it a candidate?
                const keyLc = key.toLowerCase();
                if (keyLc === 'id' || keyLc === typeNameId) {
                    // infer this property is the key; stop further analysis
                    prop.isPartOfKey = true;
                }
            }
        }
        return this;
    }

    setNamespace(defaultNamespace: string): TypeDefintion<any>  {
        this.namespace = this.namespace || defaultNamespace;
        return this;
    }

    replaceDataPropAliases(): TypeDefintion<any>  {

        if (!this.dataProperties) {
            return this;
        }

        const objKeys = Object.keys(this.dataProperties);

        for (const oKey of objKeys) {
            const prop = this.dataProperties[oKey];

            const propKeys = Object.keys(prop);

            for (const key of propKeys) {

                const keyLc = key.toLowerCase();

                if (keyLc === 'type') {
                    this.removeAttribute(prop, key, 'dataType');
                }
                if (keyLc === 'complex' || keyLc === 'complextype') {
                    this.removeAttribute(prop, key, 'complexTypeName');
                } else if (keyLc === 'max' && (prop.dataType === undefined || prop.dataType === DataType.String)) {
                    this.removeAttribute(prop, key, 'maxLength');
                } else if (keyLc.indexOf('null') > -1 && key !== 'isNullable' && typeof (prop[key]) === 'boolean') {
                    this.removeAttribute(prop, key, 'isNullable');
                } else if (keyLc === 'required') {
                    prop[key] = !prop[key];
                    this.removeAttribute(prop, key, 'isNullable');
                } else if (keyLc.indexOf('key') > -1 && key !== 'isPartOfKey' && typeof (prop[key]) === 'boolean') {
                    this.removeAttribute(prop, key, 'isPartOfKey');
                } else if (keyLc === 'default') {
                    this.removeAttribute(prop, key, 'defaultValue');
                } else if (keyLc === 'isone' || keyLc === 'hasone') {
                    this.removeAttribute(prop, key, 'isScalar');
                    // Mongo subdocuments could be collections of complex types
                } else if (keyLc === 'ismany' || keyLc === 'hasmany') {
                    prop[key] = !prop[key];
                    this.removeAttribute(prop, key, 'isScalar');
                }
            }

            if (prop.complexTypeName && prop.complexTypeName.indexOf(':#') === -1) {
                // if complexTypeName is unqualified, suffix with the entity's own namespace
                prop.complexTypeName += ':#' + this.namespace;
            }
        }
        return this;
    }
    /*
     *  Support common aliases in Navigation Property attributes to reduce tedium
     *  type -> entityTypeName
     *  FK|FKs -> foreignKeyNames
     *  invFK|invFKs -> invForeignKeyNames
     *  assoc -> associationName
     *  isOne | hasOne -> isScalar
     *  isMany | hasMany -> isScalar with boolean flipped
     */
    replaceNavPropAliases(): TypeDefintion<any>  {

        if (!this.navigationProperties) {
            return this;
        }
        const objKeys = Object.keys(this.navigationProperties);

        for (const nKey of objKeys) {

            const prop =
            this.navigationProperties[nKey] =
            this.normalizeNavProp(nKey, this.navigationProperties[nKey]) as any;


            const propKeys = Object.keys(prop)

            for (const key of propKeys) {
                const keyLc = key.toLowerCase();

                switch (keyLc) {
                    case 'type':
                        this.removeAttribute(prop, key, 'entityTypeName');
                        break;
                    case 'fk':
                    case 'fks':
                    case 'key':
                        this.removeAttribute(prop, key, 'foreignKeyNames');
                        break;
                    case 'isone':
                    case 'hasone':
                        this.removeAttribute(prop, key, 'isScalar');
                        break;
                    case 'ismany':
                    case 'hasmany':
                        prop[key] = !prop[key];
                        this.removeAttribute(prop, key, 'isScalar');
                        break;
                    case 'invfk':
                    case 'invfks':
                        this.removeAttribute(prop, key, 'invForeignKeyNames');
                        break;
                    default:
                        if (keyLc.indexOf('assoc') > -1 && key !== 'associationName') {
                            this.removeAttribute(prop, key, 'associationName');
                        }
                }
            }

            let propTypeName = prop.entityTypeName;

            // append the namespace to entityTypeName if missing
            const nsStart = propTypeName.indexOf(':#');
            if (nsStart === -1) {
                // name is unqualified; append the namespace
                prop.entityTypeName += ':#' + this.namespace;
            } else {
                propTypeName = propTypeName.slice(0, nsStart);
            }

            // Infer that it's a child nav if no FKs, no invFKs, and not a collection
            if (prop.foreignKeyNames === undefined && prop.isScalar !== false &&
                prop.invForeignKeyNames === undefined) {
                // Look for candidate FK property among the data properties as
                // (1) propertyname + id OR (2) unqualified typename + 'id'
                const candidate1 = nKey.toLowerCase() + 'id';
                const candidate2 = propTypeName.toLowerCase() + 'id';
                const fk = Object.keys(this.dataProperties).filter(
                    function (k) {
                        k = k.toLowerCase();
                        return k === candidate1 || k === candidate2;
                    })[0];
                if (fk) { prop.foreignKeyNames = [fk]; }
            }

            if (prop.associationName === undefined) {
                const isParent = prop.isScalar === false ||
                               prop.invForeignKeyNames ||
                               prop.foreignKeyNames === undefined;
                // association name is 'ChildType_ParentType'
                prop.associationName =
                    (isParent ? propTypeName : this.typeName) + '_' +
                    (isParent ? this.typeName : propTypeName);
            }

            // coerce FK names to array
            let keyNames = prop.foreignKeyNames;
            if (keyNames && !Array.isArray(keyNames)) {
                prop.foreignKeyNames = [keyNames];
            }
            keyNames = prop.invForeignKeyNames;
            if (keyNames && !Array.isArray(keyNames)) {
                prop.invForeignKeyNames = [keyNames];
            }

        }
        return this;
    }
}
