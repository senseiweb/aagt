// import { Injectable } from '@angular/core';
// import {
//     AbstractDataServiceAdapter,
//     MetadataStore,
//     DataService,
//     config,
//     core,
//     MappingContext,
//     EntityType,
//     EntityQuery,
//     EntityState,
//     SaveBundle,
//     SaveResult,
//     SaveContext,
//     HttpResponse,
//     AutoGeneratedKeyType,
//     EntityProperty,
//     DataProperty,
//     DataType,
//     Entity,
//     JsonResultsAdapter,
//     NodeContext
// } from 'breeze-client';

// import { QueryResult, ServerError, SaveErrorFromServer } from 'breeze-client/src/entity-manager';

// import { CustomSaveContext } from './sp-dataservice-save';
// import { CustomDataServiceUtils } from './sp-dataservice-utils';

// /**
//  * Built from example at https://github.com/Breeze/breeze-client/blob/master/src/abstract-data-service-adapter.ts
//  */

// @Injectable()
// export class CustomSpDsataService extends AbstractDataServiceAdapter {
//     defaultHeaders: { [index: string]: string };
//     requestDigest: string;

//     constructor(private utils: CustomDataServiceUtils) {
//         super();
//         this.name = 'SpCustomDataService';
//         this.defaultHeaders = {
//             Accept: 'application/json;odata=verbose',
//             DataServiceVersion: '3.0',
//             'Content-Type': 'application/json;odata=verbose'
//         };
//     }

//     // jsonResultsAdapter(): JsonResultsAdapter {
//     //     return new JsonResultsAdapter({
//     //         visitNode: 
//     //     })
//     // }


//     executeQuery(mappingContext: MappingContext): Promise<QueryResult> {
//         mappingContext.adapter = this;
//         const query = mappingContext.query as EntityQuery;
//         const entityType = this.getEntityTypeFromMappingContext(mappingContext);
//         const custom = (entityType && entityType.custom) || ({} as any);
//         if (!query.selectClause && custom['defaultSelect']) {
//             mappingContext.query = query.select(custom.defaultSelect);
//         }

//         const executeQueryPromise = new Promise<QueryResult>((resolver, reject) => {
//             const httpOptions = {
//                 type: 'GET',
//                 url: mappingContext.getUrl(),
//                 headers: this.getRequestDigestHeaders(),
//                 params: query.parameters,
//                 dataType: 'json',
//                 crossDomain: false,
//                 success: (response: HttpResponse) => {
//                     try {
//                         const data = this.executeQuerySuccess(response, mappingContext);
//                         resolver(data);
//                     } catch (e) {
//                         if (e instanceof Error) {
//                             reject(e);
//                         } else {
//                             this.handleHttpErrors(reject, response);
//                         }
//                     }
//                 },
//                 error: (response: HttpResponse) => {
//                     this.handleHttpErrors(reject, response);
//                 }
//             };

//             if (mappingContext.dataService.useJsonp) {
//                 httpOptions.dataType = 'jsonp';
//                 httpOptions.crossDomain = true;
//             }

//             this.ajaxImpl.ajax(httpOptions);
//         });
//         return executeQueryPromise;
//     }

//     private executeQuerySuccess(response: HttpResponse, mc: MappingContext): QueryResult {
//         const unwrappedData = this.unwrapResponseData(response);
//         let rData: QueryResult;

//         if (unwrappedData) {
//             rData = {
//                 results: unwrappedData,
//                 inlineCount: unwrappedData.__count ? parseInt(unwrappedData.__count, 10) : undefined,
//                 httpResponse: response,
//                 query: mc.query
//             };
//         } else {
//             rData = {
//                 results: response.data,
//                 httpResponse: response,
//                 query: mc.query
//             };
//         }
//         return rData;
//     }

//     fetchMetadata(metadataStore: MetadataStore, dataService: DataService): Promise<any> {
//         const error = new Error('This dataservice does not support metadata retriveal from sharepoint');
//         return Promise.reject(error);
//     }

//     getRequestDigestHeaders(): Object {
//         const defaultHeader = {};
//         Object.assign(defaultHeader, this.defaultHeaders);
//         if (this.requestDigest) {
//             defaultHeader['X-RequestDigest'] = this.requestDigest;
//         }
//         return defaultHeader;
//     }

//     private getEntityTypeFromMappingContext(mc: MappingContext): EntityType | undefined {
//         const query = mc.query;
//         if (!query || typeof query === 'string') {
//             return undefined;
//         }
//         let et = query.resultEntityType as EntityType;
//         if (!et) {
//             const etName = mc.metadataStore.getEntityTypeNameForResourceName(query.resourceName);
//             if (etName) {
//                 et = mc.metadataStore.getEntityType(etName) as EntityType;
//             }
//         }
//         return et;
//     }

//     initialize(): void {
//         this.utils.ajaxAdapter = config.getAdapterInstance('ajax');
//         if (this.utils.ajaxAdapter && this.utils.ajaxAdapter.ajax) {
//             return;
//         }
//         throw new Error(`Unable to find ajax adapter for dataservice adapter ${this.name || ''}`);
//     }

//     saveChanges(saveContext: SaveContext, saveBundle: SaveBundle): Promise<SaveResult> {
//         const saveCtx = new CustomSaveContext(saveContext, saveBundle, this.utils);
//         return saveCtx.save(this.getRequestDigestHeaders());
//     }

//     // Determine if this is an Entity node and update the node appropriately if so
//     updateEntityNode(node: any, mappingContext: MappingContext): void {
//         const metadata = node.__metadata; // every SharePoint entity node has __metadata

//         if (!metadata) { return; }

//         const entityType = node.$entityType;

//         if (entityType) {
//             // save result node

//         }
//     }

//     visitNode(node: any, mappingContext: MappingContext, nodeContext: NodeContext): any {
//         if (!node) { return {}; }

//         const propertyName = nodeContext.propertyName;

//         const ignore = node.__deferred !== null || propertyName === '__metadata' ||
//             // EntityKey properties can be produced by EDMX models
//             (propertyName === 'EntityKey' && node.$type && core.stringStartsWith(node.$type, 'System.Data'));
        
//         if (!ignore) {
            
//             return {
//                 entityType: entityType,
//                 nodeId: node.$id,
//                 nodeRefId: node.$ref,
//                 ignore: ignore
//               } as any;
//         }

//     }

// }
