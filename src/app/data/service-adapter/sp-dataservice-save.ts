import {
    SaveContext,
    SaveBundle,
    SaveResult,
    Entity,
    AutoGeneratedKeyType,
    DataProperty,
    DataType,
    HttpResponse,
    EntityKey,
    EntityState
} from 'breeze-client';

import { CustomDataServiceUtils } from './sp-dataservice-utils';
import { EntityStateSymbol } from 'breeze';
import { AnyAaaaRecord } from 'dns';

export class CustomSaveContext {
    private headers: Object;

    constructor(private saveContext: SaveContext, private saveBundle: SaveBundle, private utils: CustomDataServiceUtils) {}

    private addKeyMapping(response: HttpResponse, index: number, unwrappedResponse: any): any {
        const tempKey = response.saveContext.tempKeys[index] as EntityKey;
        if (tempKey) {
            // entity had a temporary key; add a temp-to-perm key mapping
            const entityType = tempKey.entityType;
            const tempValue = tempKey.values[0];
            const realKey = entityType.getEntityKeyFromRawEntity(entityType, unwrappedResponse);
            const keyMapping = {
                entityTypeName: entityType.name,
                tempValue: tempValue,
                realValue: realKey.values[0]
            };
            response.saveContext.saveResult.keyMappings.push(keyMapping);
        }
    }

    private makeSaveResult(response: HttpResponse, index: number): Entity {
        let savedData = this.utils.unwrapResponseData(response) as any;

        if (savedData && typeof savedData === 'object') {
            // Have "saved entity" data; add its type (for JsonResultsAdapter) & KeyMapping
            savedData.$entityType = response.saveContext.originalEntities[index].entityType;
            this.addKeyMapping(response, index, savedData);
        } else {
            // No "saved entity" data; return the original entity
            savedData = this.saveContext.originalEntities[index] as any;
        }
        this.saveContext.saveResult.entities.push(savedData);
        return savedData;
    }

    private prepareSaveBundles(): Promise<SaveResult>[] {
        this.saveContext.tempKeys = [];
        this.saveContext.originalEntities = this.saveBundle.entities;
        const saveCombo = this.saveBundle.entities.map((entity, index) => {
            const state = entity.entityAspect.entityState;
            switch (state) {
                case EntityState.Added:
                    return this.processAddChangeSet(entity, index);
                case EntityState.Modified:
                    return this.processModifyChangeSet(entity, index);
                case EntityState.Deleted:
                    return this.processModifyChangeSet(entity, index);
            }
        });
        return saveCombo;
    }

    private processAddChangeSet(entity: Entity, index: number): Promise<SaveResult> {
        const defaultHeaders = {};
        Object.assign(defaultHeaders, this.headers);
        let rawEntity: any;
        const url = this.saveContext.dataService.qualifyUrl(this.saveContext.resourceName);
        const em = this.saveContext.entityManager;
        const et = entity.entityType;
        const aspect = entity.entityAspect;
        const helper = em.helper;

        if (!et.defaultResourceName) {
            throw new Error(`Missing resource name for type: ${et.name}`);
        }

        if (et.autoGeneratedKeyType !== AutoGeneratedKeyType.None) {
            this.saveContext.tempKeys[index] = aspect.getKey();
        }

        rawEntity = helper.unwrapInstance(entity, this.normalizeSaveValue);

        rawEntity.__metadata = {
            type: this.utils.clientTypeNameToServer(et.shortName)
        };

        const payload = JSON.stringify(rawEntity);
        const that = this;
        return new Promise<SaveResult>((resolve, reject) => {
            function success(response: HttpResponse): void {
                response.saveContext = that.saveContext;
                const data = that.utils.unwrapResponseData(response);

                if (data && (data.Error || data.error)) {
                    that.utils.handleHttpErrors(reject, response);
                } else {
                    const savedEntity = that.reviewSaveResult()
                    const saveResult = that.makeSaveResult(response, index);
                    resolve(saveResult);
                }
            }

            function failed(response: HttpResponse): void {
                response.saveContext = this.saveContext;
                that.utils.handleHttpErrors(reject, response);
            }
            const requestCfg = {
                url: url + et.defaultResourceName,
                type: 'POST',
                data: payload,
                headers: defaultHeaders,
                success: (response: HttpResponse) => success(response),
                error: (response: HttpResponse) => failed(response)
            };

            this.utils.ajaxAdapter.ajax(requestCfg);
        }).catch(error =>  error );
    }

    private processDeleteChangeSet(entity: Entity, index: number): Promise<SaveResult> {
    }

    private processModifyChangeSet(entity: Entity, index: number): Promise<SaveResult> {

    }

    private normalizeSaveValue(prop: DataProperty, val: any): any {
        if (prop.isUnmapped) {
            return undefined;
        }
        if (prop.dataType === DataType.DateTimeOffset) {
            val = val && new Date(val.getTime() - val.getTimezoneOffset() * 60000);
        } else if (prop.dataType.quoteJsonOData) {
            val = val != null ? val.toString() : val;
        }
        return val;
    }

    private reviewSaveResult(savedEntity: {[index: string]: any}): Entity {
        const saveResult = this.saveContext.saveResult;
        const etWithErrors = saveResult.entities;
    }

    save(headers: Object): Promise<SaveResult>[] {
        this.headers = headers;
        const saveCombobundle = this.prepareSaveBundles();
        return Promise.all(saveCombobundle)
        .then()
    }
}
