import { Injectable } from '@angular/core';

import {
    config,
    AutoGeneratedKeyType,
    DataService,
    EntityManager,
    EntityType,
    MetadataStore,
    NamingConvention
} from 'breeze-client';

import { HttpClient, HttpHeaders } from '@angular/common/http';
import { OData3Batch, OData3BatchService } from '@odata';
import { AppConfig } from 'app/app-config.service';
import * as _ from 'lodash';
import { GlobalDataModule } from '../data.module';
import { SpMetadataMetadata } from '../models';
import * as eb from '../models/_entity-base';
import { GlobalUserMetadata } from '../models/user.model';
import { CustomMetadataHelperService } from '../service-adapter/custom-metadata-helper';
import { CustomNameConventionService } from '../service-adapter/custom-namingConventionDict';
import { SpODataDataService } from '../service-adapter/sharepoint-odata-dataservice';
import { CustomDataServiceUtils } from '../service-adapter/sp-dataservice-utils';

const appEntities = [SpMetadataMetadata, GlobalUserMetadata] as any;

@Injectable({ providedIn: GlobalDataModule })
export class CoreEmProviderService {
    activate = false;
    entityManager: EntityManager;
    servicePoint: string;
    metadataStore: MetadataStore;
    private dataService: DataService;
    constructor(
        private http: HttpClient,
        private appCfg: AppConfig,
        private odataService: OData3BatchService,
        private metadataHelper: CustomMetadataHelperService,
        private namingDict: CustomNameConventionService,
        private spDataAdapater: SpODataDataService
    ) {
        this.fetchRequestDigest();
        this.init();
    }

    protected init(): void {
        const dataAdapter = config.initializeAdapterInstance(
            'dataService',
            this.spDataAdapater.name,
            true
        );
        dataAdapter.utils = new CustomDataServiceUtils();
        dataAdapter.odataService = this.odataService;

        this.dataService = new DataService({
            serviceName: this.appCfg.apiAddress(''),
            hasServerMetadata: false,
            adapterName: 'SpODataService'
        });

        this.dataService.odataServiceEndpoint = this.appCfg.featureSpAppSite(
            ''
        );
        this.metadataHelper.defaultNamespace = 'SP.Data';
        this.metadataHelper.defaultAutoGenKeyType =
            AutoGeneratedKeyType.Identity;
        const clientToServerNameDictionary = {};

        appEntities.forEach(entity => {
            const e = new entity();
            e.entityDefinition.createNamingDictionary(
                clientToServerNameDictionary,
                ''
            );
        });

        const convention = this.namingDict.createNameDictionary(
            'spNameConv',
            NamingConvention.camelCase,
            clientToServerNameDictionary
        );
        convention.setAsDefault();
        const metadataStore = (this.metadataStore = new MetadataStore());

        this.entityManager = new EntityManager({
            dataService: this.dataService,
            metadataStore
        });

        appEntities.forEach(entity => {
            const e = new entity();
            const type = this.metadataHelper.addTypeToStore(
                metadataStore,
                e.entityDefinition as any
            ) as EntityType;
            metadataStore.registerEntityTypeCtor(
                type.shortName,
                e.metadataFor,
                e.initializer
            );
            e.addDefaultSelect(type);
        });
    }

    private fetchRequestDigest(): void {
        const headers = new HttpHeaders({
            'Content-Type': 'application/json;odata=verbose',
            Accept: 'application/json;odata=verbose'
        });
        this.http
            .post(`${this.appCfg.apiAddress('')}contextinfo`, {}, { headers })
            .subscribe(response => {
                const digest =
                    response['d']['GetContextWebInformation'][
                        'FormDigestValue'
                    ];
                let timeout =
                    response['d']['GetContextWebInformation'][
                        'FormDigestTimeoutSeconds'
                    ];
                if (timeout) {
                    timeout *= 1000;
                    setTimeout(() => {
                        this.fetchRequestDigest();
                    }, timeout);
                }
                this.entityManager.dataService.requestDigest = digest;
            });
    }
}
