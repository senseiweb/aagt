import { OData3Batch, OData3BatchService, OData3Request, OData3Response } from '@odata';
import { UUID } from 'angular2-uuid';
import { AutoGeneratedKeyType, DataProperty, DataType, Entity, EntityState, SaveBundle, SaveContext, SaveResult } from 'breeze-client';
import { SpEntityBase } from '../models';
import { CustomDataServiceUtils } from './sp-dataservice-utils';

export class SpDataServiceOdataSave {
    constructor(
        private saveContext: SaveContext,
        private odataService: OData3BatchService,
        private saveBundle: SaveBundle,
        private utils: CustomDataServiceUtils,
        defaultBatchHeaders: { [index: string]: string }
    ) {
        this.uuid = UUID.UUID();
        const batchUrl = this.saveContext.dataService.serviceName + '$batch';
        this.batch = this.odataService.createBatch(batchUrl);
        const batchHeaders = this.utils.getRequestDigestHeaders(defaultBatchHeaders);
        this.batch.addHeaders(batchHeaders);
    }
    private batch: OData3Batch;
    private uuid: UUID;

    private prepareSaveBundles(): void {
        this.saveContext.tempKeys = [];
        this.saveContext.originalEntities = [];
        const saveResult: SaveResult = {
            entities: [],
            entitiesWithErrors: [],
            keyMappings: [],
            deletedKeys: []
        };
        this.saveContext.saveResult = saveResult;

        this.saveBundle.entities.forEach((entity, index) => {
            const state = entity.entityAspect.entityState;
            const contentId = index + 1;
            this.saveContext.originalEntities[contentId] = entity;
            let request: OData3Request;

            const changeSet = this.odataService.createChangeset(this.uuid);

            switch (state) {
                case EntityState.Added:
                    request = this.processAddChangeSet(entity, contentId);
                    break;
                case EntityState.Modified:
                    request = this.processUpdateChangeSet(entity, contentId);
                    break;
                case EntityState.Deleted:
                    request = this.processDeleteChangeSet(entity as SpEntityBase, contentId);
                    break;
                default:
                    throw new Error(`Cannot save an entity whose EntityState is ${state.name}`);
            }

            changeSet.request = request;
            this.batch.addChangeset(changeSet);
        });
    }

    private processAddChangeSet(entity: Entity, contentId: number): OData3Request {
        const em = this.saveContext.entityManager;
        const aspect = entity.entityAspect;
        const et = entity.entityType;

        if (!et.defaultResourceName) {
            throw new Error(`Missing resource name for type: ${et.name}`);
        }

        if (et.autoGeneratedKeyType !== AutoGeneratedKeyType.None) {
            this.saveContext.tempKeys[contentId] = aspect.getKey();
        }

        const url = this.saveContext.entityManager.dataService.odataServiceEndpoint + et.defaultResourceName;

        const helper = em.helper;
        const rawEntity = helper.unwrapInstance(entity, this.utils.normalizeSaveValue);
        rawEntity.__metadata = {
            type: this.utils.clientTypeNameToServer(et.shortName)
        };

        const payload = JSON.stringify(rawEntity);

        return this.odataService.createRequest('POST', url, payload, contentId.toString(), undefined);
    }

    private processDeleteChangeSet(entity: SpEntityBase, contentId: number): OData3Request {
        const reqHeader = { 'IF-MATCH': '*' };
        const url = entity.__metadata.uri;
        return this.odataService.createRequest('DELETE', url, undefined, contentId.toString(), reqHeader);
    }

    private processUpdateChangeSet(entity: Entity, contentId: number): OData3Request {
        const em = this.saveContext.entityManager;
        const rawEntity = em.helper.unwrapInstance(entity, this.utils.normalizeSaveValue) as SpEntityBase;

        const reqHeaders = { 'IF-MATCH': rawEntity.__metadata.etag };

        const url = rawEntity.__metadata.uri;
        // check to see if __metadata type is added from this
        const changedData = em.helper.unwrapChangedValues(entity, em.metadataStore, this.utils.normalizeSaveValue);
        const payload = JSON.stringify(changedData);
        return this.odataService.createRequest('PATCH', url, payload, contentId.toString(), reqHeaders);
    }

    private prepareSaveResult(responses: OData3Response[]): SaveResult {
        const jra = this.saveContext.dataService.jsonResultsAdapter;
        const saveResult = this.saveContext.saveResult;

        responses.forEach(response => {
            if (!response.Success) {
                const original = this.saveContext.originalEntities[response.TempKeyIndex];
                saveResult.entitiesWithErrors.push(original);
            }
            // assume one entity per save, but may need to revisit if multiple result entities are exctracted
            const rawEntity = jra.extractSaveResults(response.Data);
            const tempKey = this.saveContext.tempKeys[response.TempKeyIndex];
            if (tempKey) {
                const tmpEt = tempKey.entityType;
                this.saveContext.saveResult.entities.push(rawEntity);
                if (tmpEt.autoGeneratedKeyType !== AutoGeneratedKeyType.None) {
                    const tempValue = tempKey.values[0];
                    const realKey = tmpEt.getEntityKeyFromRawEntity(rawEntity, DataProperty.getRawValueFromServer);
                    const keyMapping = { entityTypeName: tmpEt.name, tempValue, realValue: realKey.values[0] };
                    this.saveContext.saveResult.keyMappings.push(keyMapping);
                }
            }

            const et = this.saveContext.originalEntities[response.TempKeyIndex];
            if (et.entityAspect.entityState.isDeleted()) {
                saveResult.deletedKeys.push({
                    entityTypeName: et.entityType.name,
                    keyValues: [et.entityAspect.getKey()]
                });
            }
            saveResult.entities.push(rawEntity);
        });
        return saveResult;
    }

    async save(): Promise<SaveResult> {
        this.prepareSaveBundles();
        try {
            const serverReply = await this.odataService.submitBatch(this.batch);
            this.saveContext.saveResult.httpResponse = serverReply.rawResponse;
            return this.prepareSaveResult(serverReply.responses);
        } catch (error) {
            throw new Error(error);
        }
    }
}
