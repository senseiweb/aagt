import { OData3Batch, OData3BatchService, OData3Request, OData3Response } from '@odata';
import { UUID } from 'angular2-uuid';
import { AutoGeneratedKeyType, DataProperty, DataType, Entity, EntityState, SaveBundle, SaveContext, SaveResult } from 'breeze-client';
import { SpEntityBase } from '../models';
import { CustomDataServiceUtils } from './sp-dataservice-utils';

export class SpDataServiceOdataSave {
    constructor(
        private saveContext: SaveContext,
        private odataService: OData3BatchService,
        private saveBundle: SaveBundle,
        private utils: CustomDataServiceUtils,
        defaultBatchHeaders: { [index: string]: string }
    ) {
        this.uuid = UUID.UUID();
        const batchUrl = this.saveContext.dataService.serviceName + '$batch';
        this.batch = this.odataService.createBatch(batchUrl);
        this.defaultHeaders = defaultBatchHeaders;
        const batchHeaders = this.utils.getRequestDigestHeaders(defaultBatchHeaders);
        this.batch.addHeaders(batchHeaders);
    }
    private batch: OData3Batch;
    private defaultHeaders: { [index: string]: string };
    private uuid: UUID;

    private prepare;

    private normalizeSaveValue(prop: DataProperty, val: any): any {
        if (prop.isUnmapped) {
            return undefined;
        }
        const propDataType = prop.dataType as DataType;
        if (propDataType === DataType.DateTimeOffset) {
            val = val && new Date(val.getTime() - val.getTimezoneOffset() * 60000);
        } else if (prop.dataType) {
            // quoteJsonOData
            val = val != null ? val.toString() : val;
        }
        return val;
    }

    private prepareSaveBundles(): void {
        this.saveContext.tempKeys = [];
        const saveResult: SaveResult = {
            entities: [],
            entitiesWithErrors: [],
            keyMappings: []
        };
        this.saveContext.saveResult = saveResult;

        this.saveBundle.entities.forEach((entity, index) => {
            const state = entity.entityAspect.entityState;
            this.saveContext.originalEntities[index] = entity;
            const contentId = index + 1;
            const contentId2 = index + 2;
            const contentId3 = index + 3;
            let request: OData3Request;
            let request2: OData3Request;
            let request3: OData3Request;

            const changeSet = this.odataService.createChangeset(this.uuid);
            const changeSet2 = this.odataService.createChangeset(this.uuid);
            const changeSet3 = this.odataService.createChangeset(this.uuid);

            switch (state) {
                case EntityState.Added:
                    request = this.processAddChangeSet(entity, contentId);
                    request2 = this.processAddChangeSet(entity, contentId2);
                    request3 = this.processAddChangeSet(entity, contentId3);

                    break;
                case EntityState.Modified:
                    request = this.processUpdateChangeSet(entity, index + 1);
                    break;
                case EntityState.Deleted:
                    request = this.processDeleteChangeSet(entity as SpEntityBase, index + 1);
                    break;
                default:
                    throw new Error(`Cannot save an entity whose EntityState is ${state.name}`);
            }

            changeSet.request = request;
            changeSet2.request = request2;
            changeSet3.request = request3;

            this.batch.addChangeset(changeSet);
            this.batch.addChangeset(changeSet2);
            this.batch.addChangeset(changeSet3);
        });
    }

    private processAddChangeSet(entity: Entity, contentId: number): OData3Request {
        const em = this.saveContext.entityManager;
        const aspect = entity.entityAspect;
        const et = entity.entityType;
        // const addHeaders = new HttpHeaders({
        //     'Content-Type': 'application/http',
        //     'Content-Transfer-Encoding': 'binary'
        // });

        if (!et.defaultResourceName) {
            throw new Error(`Missing resource name for type: ${et.name}`);
        }

        if (et.autoGeneratedKeyType !== AutoGeneratedKeyType.None) {
            this.saveContext.tempKeys[contentId] = aspect.getKey();
        }

        const url = this.saveContext.entityManager.dataService.odataServiceEndpoint + et.defaultResourceName;

        const helper = em.helper;
        const rawEntity = helper.unwrapInstance(entity, this.normalizeSaveValue);
        rawEntity.__metadata = {
            type: this.utils.clientTypeNameToServer(et.shortName)
        };

        const payload = JSON.stringify(rawEntity);

        return this.odataService.createRequest('POST', url, payload, contentId.toString(), undefined);
    }

    private processDeleteChangeSet(entity: SpEntityBase, contentId: number): OData3Request {
        const reqHeader = { 'IF-MATCH': '*' };
        const url = entity.__metadata.uri;
        return this.odataService.createRequest('DELETE', url, undefined, contentId.toString(), reqHeader);
    }

    private processUpdateChangeSet(entity: Entity, contentId: number): OData3Request {
        const em = this.saveContext.entityManager;
        const rawEntity = em.helper.unwrapInstance(entity, this.normalizeSaveValue) as SpEntityBase;

        const reqHeaders = { 'IF-MATCH': rawEntity.__metadata.etag };
        // const defaultHeaderKeys = Object.keys(this.defaultHeaders);
        // for (const key of defaultHeaderKeys) {
        //     reqHeaders[key] = this.defaultHeaders[key];
        // }
        const url = rawEntity.__metadata.uri;
        // check to see if __metadata type is added from this
        const changedData = em.helper.unwrapChangedValues(entity, em.metadataStore, this.normalizeSaveValue);
        const payload = JSON.stringify(changedData);
        return this.odataService.createRequest('PATCH', url, payload, contentId.toString(), reqHeaders);
    }

    private preparSaveResult(responses: OData3Response[]): SaveResult {
        const jra = this.saveContext.dataService.jsonResultsAdapter;
        const saveResult = this.saveContext.saveResult;

        responses.forEach(response => {
            if (!response.Success) {
                const original = this.saveContext.originalEntities[response.TempKeyIndex];
                saveResult.entitiesWithErrors.push(original);
            }
            // assume one entity per save, but may need to revisit if multiple result entities are exctracted
            const rawEntity = jra.extractSaveResults(response);
            const tempKey = this.saveContext.tempKeys[response.TempKeyIndex];
            if (tempKey) {
                const et = tempKey.entityType;
                this.saveContext.saveResult.entities.push(rawEntity);
                if (et.autoGeneratedKeyType !== AutoGeneratedKeyType.None) {
                    const tempValue = tempKey.values[0];
                    const realKey = et.getEntityKeyFromRawEntity(rawEntity, DataProperty.getRawValueFromServer);
                    const keyMapping = { entityTypeName: et.name, tempValue, realValue: realKey.values[0] };
                    this.saveContext.saveResult.keyMappings.push(keyMapping);
                }
            }
            saveResult.entities.push(rawEntity);
        });
        return saveResult;
    }

    async save(): Promise<SaveResult> {
        this.prepareSaveBundles();
        const serverReply = await this.odataService.submitBatch(this.batch);
        this.saveContext.saveResult.httpResponse = serverReply.rawResponse;
        return this.preparSaveResult(serverReply.responses);
    }
}
