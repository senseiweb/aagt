import { Injectable } from '@angular/core';
import { CustomDataServiceUtils } from '../service-adapter/sp-dataservice-utils';

import { EntityManager, AutoGeneratedKeyType, config, DataService, EntityType, NamingConvention, MetadataStore } from 'breeze-client';

import * as eb from '../global-models/_entity-base';
import { EmProviderConfig } from './em-provider-config';
import * as _ from 'lodash';
import { CustomNameConventionService } from '../service-adapter/custom-namingConventionDict';
import { CustomMetadataHelperService } from '../service-adapter/custom-metadata-helper';
import { SpODataDataService } from '../service-adapter/sharepoint-odata-dataservice';
import { OData3BatchService } from '@odata';
import { HttpHeaders, HttpClient } from '@angular/common/http';
import { AppConfig } from 'app/app-config.service';
import { MetadataStoreConfig } from 'breeze-client/src/entity-metadata';

@Injectable({ providedIn: 'root' })
export class EmProviderService {
    activate = false;
    entityManager: EntityManager;
    servicePoint: string;

    constructor(
        private emCfg: EmProviderConfig,
        private utils: CustomDataServiceUtils,
        private http: HttpClient,
        private appCfg: AppConfig,
        private metadataHelper: CustomMetadataHelperService,
        private odataService: OData3BatchService,
        private spODataServ: SpODataDataService,
        private namingDict: CustomNameConventionService
    ) {
        this.fetchRequestDigest();
        this.init();
    }

    protected init(): void {
        const dataAdapter = config.initializeAdapterInstance('dataService', 'SpODataService', true) as any;
        dataAdapter.utils = this.utils;
        dataAdapter.odataService = this.odataService;

        const dataService = new DataService({
            serviceName: this.appCfg.apiAddress(this.emCfg.featureSpAppName),
            hasServerMetadata: false
        });

        const clientToServerNameDictionary = {};

        this.metadataHelper.defaultNamespace = this.emCfg.nameSpace;
        this.metadataHelper.defaultAutoGenKeyType = AutoGeneratedKeyType.Identity;

        this.emCfg.entities.forEach(entity => {
            const e = new entity() as eb.MetadataBase<eb.SpEntityBase>;
            if (e.entityDefinition.typeClientToServerDictionary) {
                Object.assign(clientToServerNameDictionary, e.entityDefinition.typeClientToServerDictionary);
            }
        });

        const convention = this.namingDict.createNameDictionary('spNameConv', NamingConvention.camelCase, clientToServerNameDictionary);

        convention.setAsDefault();

        const metadataStoreCfg: MetadataStoreConfig = {
            namingConvention: convention
        };

        const metadataStore = new MetadataStore(metadataStoreCfg);

        this.entityManager = new EntityManager({
            dataService: dataService,
            metadataStore: metadataStore
        });

        const store = this.entityManager.metadataStore;

        this.emCfg.entities.forEach(entity => {
            const e = new entity() as eb.MetadataBase<eb.SpEntityBase>;
            if (e.entityDefinition.typeClientToServerDictionary) {
                Object.assign(clientToServerNameDictionary, e.entityDefinition.typeClientToServerDictionary);
            }
            const type = this.metadataHelper.addTypeToStore(store, e.entityDefinition as any) as EntityType;
            store.registerEntityTypeCtor(type.shortName, e.metadataFor, e.initializer);
            e.addDefaultSelect(type);
        });
    }

    private fetchRequestDigest(): void {
        const headers = new HttpHeaders({
            'Content-Type': 'application/json;odata=verbose',
            Accept: 'application/json;odata=verbose'
        });
        this.http.post(`${this.appCfg.apiAddress}/_api/contextinfo`, {}, { headers: headers }).subscribe(response => {
            const digest = response['d']['GetContextWebInformation']['FormDigestValue'];
            let timeout = response['d']['GetContextWebInformation']['FormDigestTimeoutSeconds'];
            if (timeout) {
                timeout *= 1000;
                setTimeout(() => {
                    this.fetchRequestDigest();
                }, timeout);
            }
            this.utils.requestDigest = digest;
        });
    }
}
